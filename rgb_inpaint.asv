%% start
clear all
close all
clc
%% load image
I = imread('./crimsi_images/bordje_horizon.jpeg');
s=1;
I = I(1:s:end,1:s:end,1:3);
DI = double(I);
imshow(I);
%I = rgb2lab(I);
[col1, row1, dim1] = size(I);
%%
imshow(uint8(I))
roi = drawfreehand;
%% selecting area

%roi = images.roi.Freehand(gca,'Position',[10 15;100 50;100 150;15 145]);
binaryImage = createMask(roi);
imshow(binaryImage)


%% deleting area
J2 = I;
C_org = ones(col1, row1); % Confidence term
F_org = ones(col1, row1); % Filled term
for j=1:row1
    for i=1:col1
        if binaryImage(i,j) == 1
            J2(i,j,:) = NaN;
            C_org(i,j) = 0;
            F_org(i,j) = 0;
        end
    end
end 
im_org = J2;
figure
imshow(uint8(im_org))
%%
n_range = [9];
for k = 1:numel(n_range)
    n = n_range(k); %patch size
    n1 = floor(n/2); %half patch size
    alpha = 255; %
    priority = 1;
    iter = 0;
    im2 = zeros(col1+2*n, row1+2*n, dim1); % setting extra band around the image
    C2 = ones(col1+2*n, row1+2*n);
    F2 = ones(col1+2*n, row1+2*n);
    
    
    im2(n+1:col1+n,n+1:row1+n,:) = im_org;
    C2(n+1:col1+n,n+1:row1+n) = C_org;
    F2(n+1:col1+n,n+1:row1+n) = F_org;
    
    imshow(uint8(im2))
    im = im2;
    F = F2;
    C = C2; 
    [col_k, row_k, dim_k] = size(im2); %image size including extra band around image
    Im = zeros(col_k, row_k, dim_k); %image for printing intermediate results
    
    while sum(sum(1-F))>1
        iter = iter + 1
        
        %edge
        E = edge2(F);
        E2 = edge(F)-E;
        
        %gradient of the edge
        dx = [[1, 0, -1];[1, 0, -1];[1, 0, -1]];%         [Fx1, Fy1] = gradient(double(E2));
        dy = [[1, 1, 1];[0, 0, 0];[-1, -1, -1]];
        Fx1 = conv2(dx, E2);
        Fy1 = conv2(dy, E2);
        Fx1 = Fx1(2:col_k+1,2:row_k+1);
        Fy1 = Fy1(2:col_k+1,2:row_k+1);
        
        %isophote & inner product of isophoten and edge gradient
        [Ix, Iy] = gradient(double(im),50);
        Ix = Ix / alpha; Iy = Iy / alpha;
        Gx = Fy1.*Ix; Gy = Fx1.*Iy;
        Gx(isnan(Gx))=0; Gy(isnan(Gy))=0;
        Dp = sqrt(Gx.^2 + Gy.^2);
        
        Cp = confidence(C, n);
        
        Dp(isnan(Dp))=0;
        priority = Cp.*Dp;
        priority = sum(priority,3);
        
        if sum(sum(priority)) == 0
            priority = E2.*Cp;
            [y1, x1] = find(priority==max(max(priority)));
            res = randperm(length(y1),1);
            y = y1(res);
            x = x1(res);
        else
            [y1, x1] = find(priority==max(max(priority)));
            res = randperm(length(y1),1);
            y = y1(res);
            x = x1(res);
        end
        
        phi_p = phi(im, y, x, n);
        fill = phi(F, y, x, n);
        antifill = 1 - fill;
        indices = find(isnan(phi_p) == 0); 
        p_arr = phi_p(indices);
        
        err_start = 10^20;
        y2 = [];
        x2 = [];
        dist = [];
        for j = n+1+n1:row_k-n-n1
            for i = n+1+n1:col_k-n-n1
                if all(all(phi(F, i, j, n)==1))
                    phi_q = phi(im, i, j, n);
                    q_arr = phi_q(indices);
                    err = sum((q_arr-p_arr).^2,'all');
                    if err < err_start && sqrt((y-i)^2 + (x-j)^2 < dist
                        err_start = err;
                        y2 = i;
                        x2 = j;
                        dist = sqrt((y-i)^2 + (x-j)^2);
                    elseif err==err_start 
                        y2 = [y2, i];
                        x2 = [x2, j];
                        dist = [dist, sqrt((y-i)^2 + (x-j)^2)];
                    end
                end
            end
        end
        %     idy = find(dist==min(min(dist)));
        %     idy = idy(1);
        
        idy = randperm(length(y2),1);
        x1 = x2(idy);
        y1 = y2(idy);
        phi_q = phi(im, y1, x1, n);
        
        phi_p(isnan(phi_p)) = 0;
        to_fill = phi_q.*antifill + phi_p.*fill;
        im(y-n1:y+n1,x-n1:x+n1, :) = to_fill;
        F(y-n1:y+n1,x-n1:x+n1) = 1;
        C(y-n1:y+n1,x-n1:x+n1) = C(y-n1:y+n1,x-n1:x+n1).*fill + Cp(y,x)*antifill;
        sum(sum(1-F))
        if mod(iter,75) == 0
            fig_name = strcat('./Results/bord_n1_',num2str(n),'iter_',num2str(iter),'.tif');
            imwrite(uint8(im),fig_name)
            imshow(uint8(im))
        end
        
        
    end
    
    fig_name = strcat('./Results/bord_n1_',num2str(n),'iter_',num2str(iter),'_final.tif');
    imwrite(uint8(im),fig_name)
    imshow(uint8(im))
    
end




sum(sum(1-F))
%%
close all   
figure()
imshow(uint8(im))
figure()
imshow(E*255,gray)
figure()
imshow(priority*255)
%%
figure
imshow(uint8(im))

%% Functions
function kernel = phi(Im, y, x, n)
    n1 = floor(n/2);
    kernel = Im(y-n1:y+n1,x-n1:x+n1,:);
end


function SSD = err_value(phi_p, phi_q, fill)
    phi_p = double(phi_p); phi_q = double(phi_q);
    SSD = sum(sum((phi_p.*fill - phi_q.*fill).^2));
end
function Cp = confidence(C, n)
    [l, k] = size(C);
    kernel = ones(n,n);
    n1 = floor(n/2);
    a = conv2(kernel,C);
    Cp = a(n1+1:n1+l, n1+1:n1+k)/sum(sum(kernel));
    Cp(1:4,1:end) = 0;
    Cp(end-4:end,1:end) = 0;
    Cp(1:end,1:4) = 0;
    Cp(1:end,end-4:end) = 0;
end

function [x, y] = is_edge(f)
    [row, col] = size(f);
    x = [];
    y = [];
    for i = 1:row
        for j = 1:col
            if f(i, j) == 0 && abs(f(i-1,j)) + abs(f(i+1,j))+ abs(f(i,j-1)) + abs(f(i,j+1)) > 0
                x = [x, j];
                y = [y, i];
            end
        end    
    end
end

function result = edge2(f)
    [col, row] = size(f);
    edge = conv2(ones(3,3), abs(f));
    edge = edge(2:col+1,2:row+1);
    edge = edge ~=9;
    result = edge.*f;
    result = result./result;
    result(1,:) = NaN; result(:,1) = NaN; result(end,:) = NaN; result(:,end) = NaN;
    result(isnan(result))=0;
end

function result = edge(f)
    [col, row] = size(f);
    edge = conv2(ones(3,3), abs(f));
    edge = edge(2:col+1,2:row+1);
    edge1 = edge ~=9;
    filled2 = f - edge1;
    edge2 = conv2(ones(3,3), abs(filled2));
    edge2 = edge2(2:col+1,2:row+1);
    edge2 = edge2 ~=9;
    result = edge2.*f;
    result = result./result;
    result(1,:) = NaN; result(:,1) = NaN; result(end,:) = NaN; result(:,end) = NaN;
    result(isnan(result))=0;
end